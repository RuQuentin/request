Концепции

1) декларативность

2) чистая функция (не делает ничего, кроме узкой задачи). Ничего не должны менять во внешем мире. Все, что поменяла функция, мы должны получить на ее выходе.

3) Функции высшего порядка - которые принимают или возвращают другие функции. Т.е. это и любая функция, которая выполняет замыкание.

4) неизменяемость (иммутабельность) данных (immutability). Если в переменную положили значение - изменять его не должны, т.к. она может быть использована где-то еще.
Минус этого подхода в том, что нужно больше памяти, времени.
Поэтому придумали персистентные структуры данных (бинарные деревья). Например, при копировании массива нам придется перезаписать не все элементы массива, а только те ноды (которые находятся на этой ветке).

Почитать подробнее про персистентные структуры данных

5) рекурсия (recursion) - очень часто используется, т.к. в функциональном программировании нет циклов. Это очень снижает производительность.

6) ленивые вычисления (leziness) - подход, согласно которому мы не вычисляем элемен, пока он нам не понадобится в коде. В ЖС этого нет. Или же будем вычислять элемент только до тех пор, пока нам это будет необходимо.

7) map/filter/reduce/zip

8) карирование (currying). Мы можем выразить функцию с несколькими аргументами в виде ряда функций с одним аргументом.
Например:
(a, b) => a + b;
a => b => a + b
Это простое замыкание.
Например, функция фильтр принимает в себя функцию компаратор.

Композиция (близко к карированию) - это цепочка вызовов функций, где результат одной функции становится аргументом для вызова следующей.
(f и g)x => f(g(x))

Плюс этого подхода, что мы можем создавать цепочки вызовов до того, как будут переданы аргументы.

stackblitz.com - песочница VSCode

Пример реализации:
const compose = (...fns) => x => fns.reduceRight((y, f) => f(y), x);

